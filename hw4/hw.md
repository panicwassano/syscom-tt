## ADR
| Элемент | Описание |
|-------|-------|
| Title | ADR-1.<br>Обеспечение актуального рейтинга задания при начислении бонусов|
| Status | Proposed |
| Context | Менеджерам начисляются бонусы за правильное выполнение задания кандидатом в учителя, где количество бонусов зависит от рейтинга задания. В начальном варианте информация о рейтинге передавалась асинхронно в `COMM-030` в событии `TaskRating`.<br><br>При такой реализации у бизнеса возникла `Problem-030`: логика начисления бонусов некорректна из-за ошибки с рейтингом задания. Во время начисления бонусов во время изменения рейтинга происходит задержка, которая не удовлетворяет бизнес (нужно моментально).<br><br>Заинтересованные стороны текущая реализация не устраивает. |
| Decision | Решили сделать коммуникацию синхронной, используя `pull`-процессинг. При таком подходе данные будут максимально актуальными, их не нужно будет хранить. Несмотря на то, что scalability при таком подходе хуже, процессинг по такой модели проще в реализации и поддержке.<br><br>Сервис `Бонусов` будет выполнять запросы по мере поступления событий о выполненном задании, при низком performance можно будет добавить обработку батчами для нескольких задач одновременно, чтобы получать рейтинги сразу по нескольким заданиям за один запрос. |
| Consequences | Получим strong consistency информации о рейтинге. Сервис `Найма` не будет ничего знать о бонусах, но будет runtime каплинг и будет зависимость от доступности сервиса `Найма`. |
| Alternatives | В качестве альтернативы рассматривался `push`-процессинг. К весомым недостаткам можно отнести следующие проблемы:<br>1. При недоступности сервиса `Бонусов` рейтинги не дойдут до получателя, и бонусы будут начисляться с неактуальными данными<br>2. Нагрузка на сервис `Найма` будет передаваться и на сервис `Бонусов`.<br>3. Сервис `Найма` должен будет знать про существование сервиса `Бонусов` и понимать, когда отправлять рейтинги, что вызывает протекание абстракции.<br>4. При ошибках сервиса `Бонусов` нужно предусмотреть механизм ретраев. |

## Описание проблем
| Название проблемы | Из-за чего возникла проблема | Как проблема решилась |
|----|------------------|------------------|
| Problem-010 | Связи `COMM-020`, `COMM-40` и `COMM-50` работали синхронно - получали задания и зачисляли/списывали бонусы через прямые вызовы. Из-за этого вся цепочка тормозила, сервис `Бонусов` падал под нагрузкой, приходилось делать ретраи. | Перешли на EDA: стриминг заданий и событийный аккаунтинг для операций с бонусами, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-020 | Задания каждый раз запрашивались через синхронный вызов, в сервисе `Найма` эти данные отсутствовали. | Перешли на командный поход с `push`-процессингом. Как только менеджер переделал задание, мы не ждем и сразу же делаем синхронный вызов в сервис `Найма`, чтобы максимально быстро передать новую версию задания |
| Problem-030 | Рейтинг задания передавался асинхронно через `COMM-060`, чтобы вызывало в моменте задержки (Eventual Consistency) и рейтинг мог быть не совсем актуальный. | Перешли на командный подход с pull-процессингом в момент непосредственного начисления бонусов. Выбрал именно `pull` модель, т.к. сервис `Найма` не должен знать ничего о бонусах. |
| Problem-040 | Из-за синхронного начисления бонусов вся нагрузка из сервиса `Найма` передавалась на сервис `Бонусов`, который в какого-то момент не выдерживал и падал, система плохо масштабировалась | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-050 | После проверки задания сервис `Найма` пытался синхронно начислить или списать бонусы. Если сервис `Бонусов` выдавал ошибку или таймаут, то эта ошибка и показывалась в UI | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-060 | Задания каждый раз запрашивались через синхронный вызов, при большой нагрузке эта нагрузка передавалась на сервис `Заданий` | Перешли на EDA: стриминг заданий и менеджеров, что позволило снять избыточную нагрузку с сервиса `Заданий` |
| Problem-070 | Из-за ошибок при синхронном начислении бонусов запросы выполнялись повторно без передачи ключа идемпотентности | Перешли на EDA: событийный аккаунтинг. Дополнительно воспользовались паттерном Transactional Outbox и сделали идемпотентный consumer в сервисе `Бонусов`. |
| Problem-080 | Из-за синхронных связей был сильный каплинг сервиса `Найма` с другими, что не позволяло ему работать отдельно | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-090 | Все сервисы имели сильный каплинг. Никаких артефактов в виде документации, design solutions, ADRs не было. Для погружения в систему нужно было изучать написанный код, который кардинально отличался от того, что хотел бизнес. | Провели EventStorming, создав тем самым функциональную проекцию системы. Дополнили все это формальной проекцией в виде концептуальной модели данных и связями между сервисами. Написали ADR для миграции каждой связи, дополнили информацией про последовательность шагов, которые нужно учесть при миграции. Внедрили фитнес-функции в виде метрик и алертов ключевой части системы, добавили к этому набору `blue/green` deployment, tracing, логи, чтобы можно было понять, что в системе идет не так, как нужно.   |
| Problem-100 | При больших нагрузка на сервис `Найма` система падала, так как вся эта нагрузка передавалась и на другие сервисы из-за синхронных вызовов, ретраи помогали, но этого было недостаточно | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. Чтобы данные не терялись, воспользовались паттерном Transactional Outbox, acks - all от всех реплик Kafka, ретраи при отправке событий в Kafka |
