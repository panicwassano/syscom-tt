## ADR
text adr here

## Описание проблем
| Название проблемы | Из-за чего возникла проблема | Как проблема решилась |
|----|------------------|------------------|
| Problem-010 | Связи `COMM-020`, `COMM-40` и `COMM-50` работали синхронно - получали задания и зачисляли/списывали бонусы через прямые вызовы. Из-за этого вся цепочка тормозила, сервис `Бонусов` падал под нагрузкой, приходилось делать ретраи. | Перешли на EDA: стриминг заданий и событийный аккаунтинг для операций с бонусами, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-020 | Задания каждый раз запрашивались через синхронный вызов, в сервисе `Найма` эти данные отсутствовали. | Перешли на командный поход с `push`-процессингом. Как только менеджер переделал задание, мы не ждем и сразу же делаем синхронный вызов в сервис `Найма`, чтобы максимально быстро передать новую версию задания |
| Problem-030 | Рейтинг задания передавался асинхронно через `COMM-060`, чтобы вызывало в моменте задержки (Eventual Consistency) и рейтинг мог быть не совсем актуальный. | Перешли на командный подход с pull-процессингом в момент непосредственного начисления бонусов. Выбрал именно `pull` модель, т.к. сервис `Найма` не должен знать ничего о бонусах. |
| Problem-040 | Из-за синхронного начисления бонусов вся нагрузка из сервиса `Найма` передавалась на сервис `Бонусов`, который в какого-то момент не выдерживал и падал, система плохо масштабировалась | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-050 | После проверки задания сервис `Найма` пытался синхронно начислить или списать бонусы. Если сервис `Бонусов` выдавал ошибку или таймаут, то эта ошибка и показывалась в UI | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-060 | Задания каждый раз запрашивались через синхронный вызов, при большой нагрузке эта нагрузка передавалась на сервис `Заданий` | Перешли на EDA: стриминг заданий и менеджеров, что позволило снять избыточную нагрузку с сервиса `Заданий` |
| Problem-070 | Из-за ошибок при синхронном начислении бонусов запросы выполнялись повторно без передачи ключа идемпотентности | Перешли на EDA: событийный аккаунтинг. Дополнительно воспользовались паттерном Transactional Outbox и сделали идемпотентный consumer в сервисе `Бонусов`. |
| Problem-080 | Из-за синхронных связей был сильный каплинг сервиса `Найма` с другими, что не позволяло ему работать отдельно | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. |
| Problem-090 | Все сервисы имели сильный каплинг. Никаких артефактов в виде документации, design solutions, ADRs не было. Для погружения в систему нужно было изучать написанный код, который кардинально отличался от того, что хотел бизнес. | Провели EventStorming, создав тем самым функциональную проекцию системы. Дополнили все это формальной проекцией в виде концептуальной модели данных и связями между сервисами. Написали ADR для миграции каждой связи, дополнили информацией про последовательность шагов, которые нужно учесть при миграции. Внедрили фитнес-функции в виде метрик и алертов ключевой части системы, добавили к этому набору `blue/green` deployment, tracing, логи, чтобы можно было понять, что в системе идет не так, как нужно.   |
| Problem-100 | При больших нагрузка на сервис `Найма` система падала, так как вся эта нагрузка передавалась и на другие сервисы из-за синхронных вызовов, ретраи помогали, но этого было недостаточно | Перешли на EDA: событийный аккаунтинг, убрали блокирующие вызовы, повысили availability и scalability. Чтобы данные не терялись, воспользовались паттерном Transactional Outbox, acks - all от всех реплик Kafka, ретраи при отправке событий в Kafka |
