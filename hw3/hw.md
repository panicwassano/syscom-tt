## Схемы событий

- [candidate.v1
](./formal.json) — схема формального события
- [assessment.assigned.v1
](./business.json) — схема бизнес события

## Миграции коммуникаций
### Переход формальной синхронной на асинхронную event-driven
#### COMM-010
1. Добавляем событие в Schema Registry.
2. Добавляем в сервисы `Найма` и `Бонусов` консьюмеры, которые будут сохранять данные о новых менеджерах. Дубли убираем через `SQL` конструкцию `ON CONFLICT (manager_replication_id) DO NOTHING`
3. В сервисе `Заданий` добавляем продьюсер и начинаем продьюсить событие о новом менеджере, появившимся в системе.
4. Выключаем синхронную коммуникацию по фиче-флагу, убеждаемся, что проблем нет.
5. Если в сервисах `Найма` и `Бонусов` не хватает данных о менеджерах, то пишем скрипт, который возьмет данные менеджеров из БД `Заданий` и по каждому отправит формальное событие `ManagerCreated`.
6. Чистим код системы от старой коммуникации.

### Переход формальной асинхронной event-driven на синхронную
#### COMM-060
1. В сервис `Найма` добавляем новый endpoint для получения данных о рейтинге задания.
2. Переписываем бизнес-логику в сервисе `Бонусов` на синхронные вызовы в сервис `Найма`. Проверяем, что все работает, используем фиче-флаги.
3. Отключаем продьюсер в сервисе `Найма`.
4. Ждем, когда все консьюмеры обработают все данные из брокера.
5. Удаляем код консьюмеров всех сервисов потребителей.
6. Удаляем таблицу с данными, которые были получены из событий или пулл-процессинга.
7. Удаляем топик из брокера.
8. Чистим систему от старых метрик, кода, таблиц в базе.

### Переход функциональной синхронной на асинхронную event-driven
#### COMM-040
1. Добавляем событие в Schema Registry.
2. Добавляем коньсюмер в сервис `Бонусов`, бизнес-логику не добавляем, пишем данные в лог.
3. Добавляем продьюсер в сервисе `Найма` и продьюсим событие `SolutionCompleted` (задание выполнено успешно).
4. Проверяем, что все работает.
5. Добавляем бизнес-логику в консьюмер, не забываем про фиче-флаги и идемпотентность событий.
6. Отключаем синхронные запросы в сервис `Бонусов`.
7. Чистим систему от старых метрик, кода.

### Миграция для US-160
#### Связь COMM-020
1. В БД сервиса `Заданий` добавляем новое поле `knowledge_area` (varchar, nullable) в таблицу `assessments`. Код не трогаем.
2. Релизим сервис `Заданий` с изменениями в БД.
3. В сервисе `Заданий` пишем  метод-обвязку для получения старого поля, используем регулярку. Заменяем прямое получение поля на метод-обвязку.
4. Релизим сервис `Заданий` c новым методом.
5. Добавляем новую версию события в `Schema Registry`.
6. Добавляем новое поле в БД в сервиса `Найма`. Код не трогаем.
7. Релизим сервис `Найма`.
8. Перенести информацию о теме задания из колонки `title` в `knowledge_area`.
9. Добавить логику разделения старого поля сервисе `Найма`, используем регулярку.
10. Релизим сервис `Найма`.
11. В сервисе `Найма` меняем код консьюмера для обработки новой версии. Не забываем про идемпотентность.
12. В сервисе `Заданий` меняем код продьюсера для отправки новой версии.
13. В сервисе `Заданий` отключаем продьсер старой версии.
14. Релизим сервис `Заданий`.
15. Ждем, когда все консьюмеры обработают все данные старой версии из брокера.
16. Удаляем код коньсьюмера старой версии.
17. Релизим сервис `Найма`.
18. Чистим систему от старого события.

### Миграция для US-170
#### Связь COMM-010
1. Добавить новую версию события. Поля `first_name` и `last_name` заменям на `nickname`.
2. Добавляем обработку новой версии события в консьюмеры сервисов-потребителей.
3. В сервисе `Заданий` продьюсим новую версию события.
4. В сервисе `Заданий` удаляем продьюсинг старой версии события.
5. Дожидаемся пока все события старой версии обработаются консьюмерами.
6. Удаляем лишникий код в консьюмерах.
7. Чистим систему от старого события

### Решение проблем со списаниями и зачислениями
#### Список подходов
1. Используем паттерн transactional outbox, чтобы в одной транзакции обновить статус решения задания и добавить событие о списании или зачислении средств.
2. Используем retry pattern с exponentional backoff если по каким-то причинам не смогли положить данные в брокер.
3. Используем `ack: all` для подтверждения получения данных от всех реплик.
4. Используем гарантию `at-least-once` и `идемпотентность` событий, чтобы исключить повторные зачисления или списания.
5. Для невалидных событий используем `DLQ` паттерн. События из `DLQ` будем разбирать вручную.
